pipeline {
    agent {
        label 'local-agent'
    }
    environment {
        // Database and security credentials - will be set in the pipeline
        DATABASE_URL = credentials('db-connection-string')
        JWT_SECRET = credentials('jwt-secret')
        DB_PASSWORD = credentials('db-key')
        // Image configuration
        BUILD_NUMBER = "${env.BUILD_NUMBER}"
        // Environment configuration
        CORS_ORIGIN = 'https://blog.ingasti.com'
        VITE_API_URL = 'https://bapi.ingasti.com'
        // Docker registry
        REGISTRY_URL = 'localhost:5000'
    }
    stages {
        stage('Agent Dependency Setup') {
            steps {
                script {
                    echo "üîß Ensuring required system packages are installed..."
                    sh '''
                        if ! dpkg -s libcommons-lang3-java >/dev/null 2>&1; then
                            echo "Installing libcommons-lang3-java..."
                            sudo apt-get update && sudo apt-get install -y libcommons-lang3-java
                        else
                            echo "libcommons-lang3-java already installed."
                        fi
                    '''
                }
            }
        }
        stage('Checkout') {
            steps {
                checkout scm
                script {
                    // Get short commit hash
                    env.GIT_COMMIT_SHORT = sh(
                        script: "git rev-parse --short HEAD",
                        returnStdout: true
                    ).trim()
                    
                    // Set image names with commit hash
                    env.FRONTEND_IMAGE = "${REGISTRY_URL}/blog-frontend:${BUILD_NUMBER}-${env.GIT_COMMIT_SHORT}"
                    env.BACKEND_IMAGE = "${REGISTRY_URL}/blog-backend:${BUILD_NUMBER}-${env.GIT_COMMIT_SHORT}"
                    
                    echo "üöÄ Building Blog Application"
                    echo "=============================="
                    echo "üì¶ Images to build:"
                    echo "  Frontend: ${env.FRONTEND_IMAGE}"
                    echo "  Backend: ${env.BACKEND_IMAGE}"
                    echo "üåê Target URLs:"
                    echo "  Frontend: https://blog.ingasti.com"
                    echo "  Backend: https://bapi.ingasti.com"
                }
            }
        }
        
        stage('Build Backend Image') {
            steps {
                script {
                    echo "üî® Building backend Docker image..."
                    sh """
                        docker build -f api/Dockerfile.k8s -t ${env.BACKEND_IMAGE} .
                        docker tag ${env.BACKEND_IMAGE} ${REGISTRY_URL}/blog-backend:latest
                    """
                }
            }
        }
        
        stage('Build Frontend Image') {
            steps {
                script {
                    echo "üî® Building frontend Docker image..."
                    sh """
                        docker build -f client/Dockerfile.k8s -t ${env.FRONTEND_IMAGE} .
                        docker tag ${env.FRONTEND_IMAGE} ${REGISTRY_URL}/blog-frontend:latest
                    """
                }
            }
        }
        
        stage('Build OIDC Provider Image') {
            steps {
                script {
                    echo "üî® Building OIDC provider Docker image..."
                    env.OIDC_IMAGE = "${REGISTRY_URL}/oidc-provider:${BUILD_NUMBER}-${env.GIT_COMMIT_SHORT}"
                    sh """
                        docker build -f oidc-provider/Dockerfile -t ${env.OIDC_IMAGE} oidc-provider/
                        docker tag ${env.OIDC_IMAGE} ${REGISTRY_URL}/oidc-provider:latest
                    """
                }
            }
        }
        
        stage('Push Images to Registry') {
            steps {
                script {
                    echo "üì§ Pushing images to registry..."
                    sh """
                        echo "Pushing backend image..."
                        docker push ${env.BACKEND_IMAGE}
                        docker push ${REGISTRY_URL}/blog-backend:latest
                        
                        echo "Pushing frontend image..."
                        docker push ${env.FRONTEND_IMAGE}
                        docker push ${REGISTRY_URL}/blog-frontend:latest
                        
                        echo "Pushing OIDC provider image..."
                        docker push ${env.OIDC_IMAGE}
                        docker push ${REGISTRY_URL}/oidc-provider:latest
                    """
                }
            }
        }
        
        stage('Test Backend Container') {
            steps {
                script {
                    echo "üß™ Testing backend container..."
                    sh """
                        # Start backend container for testing with all required PG* env vars
                        docker run -d -p 5002:5000 --name test-backend-${BUILD_NUMBER} \
                            -e PGHOST='ingasti-pg-ingasti.c.aivencloud.com' \
                            -e PGPORT='25306' \
                            -e PGDATABASE='blog' \
                            -e PGUSER='avnadmin' \
                            -e PGPASSWORD="${DB_PASSWORD}" \
                            -e PGSSLMODE='require' \
                            -e CORS_ORIGIN="${CORS_ORIGIN}" \
                            -e NODE_ENV=production \
                            ${env.BACKEND_IMAGE}
                        
                        # Wait for container to start
                        sleep 15
                        
                        # Check container logs
                        echo "Container logs:"
                        docker logs test-backend-${BUILD_NUMBER}
                        
                        # Check if container is still running
                        if docker ps | grep test-backend-${BUILD_NUMBER}; then
                            echo "Container is running, testing health endpoint..."
                            # Test health endpoint
                            curl -f http://localhost:5002/health || (echo "Backend health check failed" && exit 1)
                            echo "‚úÖ Backend container test passed"
                        else
                            echo "‚ùå Container failed to start or exited"
                            exit 1
                        fi
                    """
                }
            }
            post {
                always {
                    script {
                        // Cleanup test container
                        sh """
                            docker stop test-backend-${BUILD_NUMBER} || true
                            docker rm test-backend-${BUILD_NUMBER} || true
                        """
                    }
                }
            }
        }
        
        stage('Test Frontend Container') {
            steps {
                script {
                    echo "üß™ Testing frontend container..."
                    sh """
                        # Start frontend container for testing
                        docker run -d -p 3001:80 --name test-frontend-${BUILD_NUMBER} \
                            -e VITE_API_URL="${VITE_API_URL}" \
                            ${env.FRONTEND_IMAGE}
                        
                        # Wait for container to start
                        sleep 15
                        
                        # Test health endpoint
                        curl -f http://localhost:3001/health || (echo "Frontend health check failed" && exit 1)
                        
                        echo "‚úÖ Frontend container test passed"
                    """
                }
            }
            post {
                always {
                    script {
                        // Cleanup test container
                        sh """
                            docker stop test-frontend-${BUILD_NUMBER} || true
                            docker rm test-frontend-${BUILD_NUMBER} || true
                        """
                    }
                }
            }
        }
        
        stage('Verify Kubernetes Access') {
            steps {
                script {
                    echo "üîç Verifying Kubernetes cluster access..."
                    sh """
                        kubectl version --client
                        kubectl cluster-info --request-timeout=10s
                        kubectl get nodes
                    """
                    echo "‚úÖ Kubernetes cluster is accessible"
                }
            }
        }
        
        stage('Update Kubernetes Secrets') {
            steps {
                script {
                    echo "üîê Updating Kubernetes secrets with Jenkins credentials..."
                    withCredentials([
                        string(credentialsId: 'db-key', variable: 'PGPASSWORD'),
                        string(credentialsId: 'jwt-secret', variable: 'JWT_SECRET')
                    ]) {
                        sh """
                            # Delete existing secret if it exists (ignore errors)
                            kubectl delete secret blog-secrets -n blog || true
                            
                            # Create new secret with current credentials
                            kubectl create secret generic blog-secrets -n blog \
                                --from-literal=PGHOST='ingasti-pg-ingasti.c.aivencloud.com' \
                                --from-literal=PGPORT='25306' \
                                --from-literal=PGDATABASE='blog' \
                                --from-literal=PGUSER='avnadmin' \
                                --from-literal=PGPASSWORD="\${PGPASSWORD}" \
                                --from-literal=BLOG_API_KEY='81128b70915fe2d690a4e55eebeb13cedf069659e8e524c1198426d7665462b0' \
                                --from-literal=GOOGLE_CLIENT_ID='dummy-google-client-id' \
                                --from-literal=GOOGLE_CLIENT_SECRET='dummy-google-client-secret'
                            
                            # Verify secret was created
                            kubectl get secret blog-secrets -n blog
                            echo "‚úÖ Kubernetes secrets updated successfully"
                        """
                    }
                }
            }
        }
        
        stage('Deploy to Kubernetes') {
            steps {
                script {
                    echo "üöÄ Deploying blog to Kubernetes..."
                    
                    // Update deployment files with current image tags
                    sh """
                        cd k8s
                        
                        # Update image tags in deployment files
                        sed -i.bak "s|localhost:5000/blog-frontend:latest|${env.FRONTEND_IMAGE}|g" frontend-deployment.yaml
                        sed -i.bak "s|localhost:5000/blog-backend:latest|${env.BACKEND_IMAGE}|g" backend-deployment.yaml
                        
                        # Apply namespace first
                        kubectl apply -f namespace.yaml
                        
                        # Apply persistent volumes
                        kubectl apply -f storage.yaml
                        
                        # Apply OIDC service account and configuration
                        kubectl apply -f service-account.yaml
                        kubectl apply -f oidc-provider.yaml
                        kubectl apply -f oidc-discovery-service.yaml
                        
                        # Deploy backend and frontend
                        kubectl apply -f backend-deployment.yaml
                        kubectl apply -f frontend-deployment.yaml
                        
                        # Apply services and ingress
                        kubectl apply -f backend-service.yaml
                        kubectl apply -f frontend-service.yaml
                        kubectl apply -f ingress.yaml
                        
                        # Wait for deployments to be ready
                        echo "‚è≥ Waiting for deployments to be ready..."
                        kubectl wait --for=condition=available --timeout=300s deployment/blog-backend -n blog
                        kubectl wait --for=condition=available --timeout=300s deployment/blog-frontend -n blog
                        
                        # Restore original deployment files
                        mv frontend-deployment.yaml.bak frontend-deployment.yaml
                        mv backend-deployment.yaml.bak backend-deployment.yaml
                    """
                    
                    echo "‚úÖ Kubernetes deployment completed"
                }
            }
        }
        
        stage('Verify Deployment') {
            steps {
                script {
                    echo "üîç Verifying blog deployment..."
                    sh """
                        # Check deployment status
                        kubectl get all -n blog
                        
                        # Check pod status
                        kubectl get pods -n blog -o wide
                        
                        # Check for any issues
                        kubectl describe pods -n blog -l app=blog-backend | grep -A 10 Events || true
                        kubectl describe pods -n blog -l app=blog-frontend | grep -A 10 Events || true
                        
                        # Internal health checks
                        echo "üè• Performing internal health checks..."
                        kubectl run health-check-backend --image=busybox --rm -i --restart=Never --timeout=60s -- /bin/sh -c "wget -qO- http://blog-backend-service.blog.svc.cluster.local/health && echo 'Backend health check passed'" || echo "Backend health check failed"
                        
                        kubectl run health-check-frontend --image=busybox --rm -i --restart=Never --timeout=60s -- /bin/sh -c "wget -qO- http://blog-frontend-service.blog.svc.cluster.local/health && echo 'Frontend health check passed'" || echo "Frontend health check failed"
                    """
                }
            }
        }
        
        stage('Show Recent Logs') {
            steps {
                script {
                    echo "üìã Recent application logs:"
                    sh """
                        echo "Backend logs:"
                        kubectl logs -n blog -l app=blog-backend --tail=20 || echo "Could not fetch backend logs"
                        
                        echo "Frontend logs:"
                        kubectl logs -n blog -l app=blog-frontend --tail=20 || echo "Could not fetch frontend logs"
                    """
                }
            }
        }
    }
    
    post {
        always {
            script {
                // Cleanup old Docker images to save space
                sh """
                    echo "üßπ Cleaning up old Docker images..."
                    # Keep only the latest 5 images for each service
                    docker images localhost:5000/blog-backend --format "table {{.Tag}}\t{{.ID}}" | tail -n +2 | grep -v latest | awk '{print \$2}' | tail -n +6 | xargs -r docker rmi || true
                    docker images localhost:5000/blog-frontend --format "table {{.Tag}}\t{{.ID}}" | tail -n +2 | grep -v latest | awk '{print \$2}' | tail -n +6 | xargs -r docker rmi || true
                """
            }
        }
        success {
            echo "üéâ Blog deployment pipeline completed successfully!"
            echo ""
            echo "üì± Blog services should be available at:"
            echo "  Frontend: https://blog.ingasti.com"
            echo "  Backend: https://bapi.ingasti.com"
            echo ""
            echo "üîç Monitor with:"
            echo "  kubectl get pods -n blog -w"
            echo "  kubectl logs -f deployment/blog-backend -n blog"
            echo "  kubectl logs -f deployment/blog-frontend -n blog"
            
            script {
                // Show final status
                sh """
                    echo "üåê Service and Ingress Status:"
                    kubectl get services -n blog
                    kubectl get ingress -n blog
                """
            }
        }
        failure {
            echo "‚ùå Blog deployment pipeline failed!"
            echo ""
            echo "üîç Debug information:"
            script {
                try {
                    sh """
                        echo "Kubernetes cluster status:"
                        kubectl get nodes || true
                        kubectl get pods -n blog || true
                        kubectl get events -n blog --sort-by=.metadata.creationTimestamp | tail -10 || true
                    """
                } catch (Exception e) {
                    echo "Could not retrieve debug information: ${e.getMessage()}"
                }
            }
        }
    }
}
